/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const DeviceStatusCode_Device_Ok: DeviceStatusCode = 0;
pub const DeviceStatusCode_Device_Err: DeviceStatusCode = 1;
pub type DeviceStatusCode = ::std::os::raw::c_int;
pub const DeviceState_DeviceState_Closed: DeviceState = 0;
pub const DeviceState_DeviceState_AwaitingConfiguration: DeviceState = 1;
pub const DeviceState_DeviceState_Armed: DeviceState = 2;
pub const DeviceState_DeviceState_Running: DeviceState = 3;
pub const DeviceState_DeviceStateCount: DeviceState = 4;
pub type DeviceState = ::std::os::raw::c_int;
pub const DeviceKind_DeviceKind_None: DeviceKind = 0;
pub const DeviceKind_DeviceKind_Camera: DeviceKind = 1;
pub const DeviceKind_DeviceKind_Storage: DeviceKind = 2;
pub const DeviceKind_DeviceKind_StageAxis: DeviceKind = 3;
pub const DeviceKind_DeviceKind_Signals: DeviceKind = 4;
pub const DeviceKind_DeviceKind_Count: DeviceKind = 5;
pub const DeviceKind_DeviceKind_Unknown: DeviceKind = 6;
pub type DeviceKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceIdentifier {
    pub driver_id: u8,
    pub device_id: u8,
    pub kind: DeviceKind,
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_DeviceIdentifier() {
    const UNINIT: ::std::mem::MaybeUninit<DeviceIdentifier> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeviceIdentifier>(),
        264usize,
        concat!("Size of: ", stringify!(DeviceIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceIdentifier>(),
        4usize,
        concat!("Alignment of ", stringify!(DeviceIdentifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceIdentifier),
            "::",
            stringify!(driver_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceIdentifier),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceIdentifier),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceIdentifier),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " Marker type identifying that an object is a \"Device\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Device {
    pub identifier: DeviceIdentifier,
    #[doc = " Set by `device_open_device()`"]
    pub driver: *mut Driver,
}
#[test]
fn bindgen_test_layout_Device() {
    const UNINIT: ::std::mem::MaybeUninit<Device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Device>(),
        272usize,
        concat!("Size of: ", stringify!(Device))
    );
    assert_eq!(
        ::std::mem::align_of::<Device>(),
        8usize,
        concat!("Alignment of ", stringify!(Device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Device),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Device),
            "::",
            stringify!(driver)
        )
    );
}
extern "C" {
    pub fn device_identifier_as_debug_string(
        buf: *mut ::std::os::raw::c_char,
        nbytes: usize,
        identifier: *const DeviceIdentifier,
    ) -> usize;
}
extern "C" {
    pub fn device_kind_as_string(state: DeviceKind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn device_state_as_string(state: DeviceState) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Driver {
    pub device_count: ::std::option::Option<unsafe extern "C" fn(arg1: *mut Driver) -> u32>,
    pub describe: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *const Driver,
            identifier: *mut DeviceIdentifier,
            i: u64,
        ) -> DeviceStatusCode,
    >,
    #[doc = " Opens a device, preparing it to be in the `AwaitingConfiguration`\n state.\n\n This function is normally called by `driver_open_device()` which in\n turn is called by functions like `camera_open()` or `storage_open()`\n in the hardware abstraction layer (HAL). `driver_open_device()` is\n responsible for actually populating the fields of the `Device`\n struct.\n\n # Example\n\n It doesn't do anything but a minimal implementation might look like:\n\n ```\n enum DeviceStatusCode (*open)(struct Driver* self,\n                                      uint64_t device_id,\n                                      struct Device** out)\n {\n     *out=(struct Device*)malloc(sizeof(struct Device));\n }\n ```\n\n @param[in] self The `Driver` instance.\n @param[in] device_id An identifier telling the `Driver` which device\n                      to open.\n @param[out] out Used to return a `Device*` as a handle to the opened\n                 device."]
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut Driver,
            device_id: u64,
            out: *mut *mut Device,
        ) -> DeviceStatusCode,
    >,
    #[doc = " Closes a device and releases any acquired resources."]
    pub close: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut Driver, in_: *mut Device) -> DeviceStatusCode,
    >,
    pub shutdown:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut Driver) -> DeviceStatusCode>,
}
#[test]
fn bindgen_test_layout_Driver() {
    const UNINIT: ::std::mem::MaybeUninit<Driver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Driver>(),
        40usize,
        concat!("Size of: ", stringify!(Driver))
    );
    assert_eq!(
        ::std::mem::align_of::<Driver>(),
        8usize,
        concat!("Alignment of ", stringify!(Driver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Driver),
            "::",
            stringify!(device_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).describe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Driver),
            "::",
            stringify!(describe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Driver),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Driver),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Driver),
            "::",
            stringify!(shutdown)
        )
    );
}
extern "C" {
    pub fn acquire_driver_init_v0(
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                is_error: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
                function: *const ::std::os::raw::c_char,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
    ) -> *mut Driver;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct String {
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the `str` buffer. Should include the terminating '\\0'\n if it exists."]
    pub nbytes: usize,
    #[doc = " 0 when `str` is heap allocated, otherwise 1.\n When 1, then the string needs to live longer than the runtime; it\n may have static storage. The caller is responsible for deallocating\n any associated resources.\n\n When 0, storage may be deallocated within the runtime using the\n standard library's `free` function."]
    pub is_ref: u8,
}
#[test]
fn bindgen_test_layout_String() {
    const UNINIT: ::std::mem::MaybeUninit<String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<String>(),
        24usize,
        concat!("Size of: ", stringify!(String))
    );
    assert_eq!(
        ::std::mem::align_of::<String>(),
        8usize,
        concat!("Alignment of ", stringify!(String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_ref) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(is_ref)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PID {
    pub proportional: f32,
    pub integral: f32,
    pub derivative: f32,
}
#[test]
fn bindgen_test_layout_PID() {
    const UNINIT: ::std::mem::MaybeUninit<PID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PID>(),
        12usize,
        concat!("Size of: ", stringify!(PID))
    );
    assert_eq!(
        ::std::mem::align_of::<PID>(),
        4usize,
        concat!("Alignment of ", stringify!(PID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proportional) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PID),
            "::",
            stringify!(proportional)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integral) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PID),
            "::",
            stringify!(integral)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).derivative) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PID),
            "::",
            stringify!(derivative)
        )
    );
}
pub const TriggerEdge_TriggerEdge_Rising: TriggerEdge = 0;
pub const TriggerEdge_TriggerEdge_Falling: TriggerEdge = 1;
pub const TriggerEdge_TriggerEdge_AnyEdge: TriggerEdge = 2;
pub const TriggerEdge_TriggerEdge_LevelHigh: TriggerEdge = 3;
pub const TriggerEdge_TriggerEdge_LevelLow: TriggerEdge = 4;
pub const TriggerEdge_TriggerEdgeCount: TriggerEdge = 5;
pub const TriggerEdge_TriggerEdge_NotApplicable: TriggerEdge = 6;
pub const TriggerEdge_TriggerEdge_Unknown: TriggerEdge = 7;
pub type TriggerEdge = ::std::os::raw::c_int;
pub const SignalIOKind_Signal_Input: SignalIOKind = 0;
pub const SignalIOKind_Signal_Output: SignalIOKind = 1;
pub type SignalIOKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trigger {
    pub enable: u8,
    pub line: u8,
    pub kind: SignalIOKind,
    pub edge: TriggerEdge,
}
#[test]
fn bindgen_test_layout_Trigger() {
    const UNINIT: ::std::mem::MaybeUninit<Trigger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Trigger>(),
        12usize,
        concat!("Size of: ", stringify!(Trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<Trigger>(),
        4usize,
        concat!("Alignment of ", stringify!(Trigger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(edge)
        )
    );
}
pub const SignalType_Signal_Analog: SignalType = 0;
pub const SignalType_Signal_Digital: SignalType = 1;
pub type SignalType = ::std::os::raw::c_int;
pub const SampleType_SampleType_u8: SampleType = 0;
pub const SampleType_SampleType_u16: SampleType = 1;
pub const SampleType_SampleType_i8: SampleType = 2;
pub const SampleType_SampleType_i16: SampleType = 3;
pub const SampleType_SampleType_f32: SampleType = 4;
pub const SampleType_SampleType_u10: SampleType = 5;
pub const SampleType_SampleType_u12: SampleType = 6;
pub const SampleType_SampleType_u14: SampleType = 7;
pub const SampleType_SampleTypeCount: SampleType = 8;
pub const SampleType_SampleType_Unknown: SampleType = 9;
pub type SampleType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleRateHz {
    pub numerator: u64,
    pub denominator: u64,
}
#[test]
fn bindgen_test_layout_SampleRateHz() {
    const UNINIT: ::std::mem::MaybeUninit<SampleRateHz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SampleRateHz>(),
        16usize,
        concat!("Size of: ", stringify!(SampleRateHz))
    );
    assert_eq!(
        ::std::mem::align_of::<SampleRateHz>(),
        8usize,
        concat!("Alignment of ", stringify!(SampleRateHz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleRateHz),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleRateHz),
            "::",
            stringify!(denominator)
        )
    );
}
pub const Direction_Direction_Forward: Direction = 0;
pub const Direction_Direction_Backward: Direction = 1;
pub const Direction_Direction_Count: Direction = 2;
pub const Direction_Direction_Unknown: Direction = 3;
pub type Direction = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltageRange {
    pub mn: f32,
    pub mx: f32,
}
#[test]
fn bindgen_test_layout_VoltageRange() {
    const UNINIT: ::std::mem::MaybeUninit<VoltageRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VoltageRange>(),
        8usize,
        concat!("Size of: ", stringify!(VoltageRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VoltageRange>(),
        4usize,
        concat!("Alignment of ", stringify!(VoltageRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VoltageRange),
            "::",
            stringify!(mn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VoltageRange),
            "::",
            stringify!(mx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageShape {
    pub dims: ImageShape_image_dims_s,
    pub strides: ImageShape_image_strides_s,
    pub type_: SampleType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageShape_image_dims_s {
    pub channels: u32,
    pub width: u32,
    pub height: u32,
    pub planes: u32,
}
#[test]
fn bindgen_test_layout_ImageShape_image_dims_s() {
    const UNINIT: ::std::mem::MaybeUninit<ImageShape_image_dims_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ImageShape_image_dims_s>(),
        16usize,
        concat!("Size of: ", stringify!(ImageShape_image_dims_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ImageShape_image_dims_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ImageShape_image_dims_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_dims_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_dims_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_dims_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_dims_s),
            "::",
            stringify!(planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageShape_image_strides_s {
    pub channels: i64,
    pub width: i64,
    pub height: i64,
    pub planes: i64,
}
#[test]
fn bindgen_test_layout_ImageShape_image_strides_s() {
    const UNINIT: ::std::mem::MaybeUninit<ImageShape_image_strides_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ImageShape_image_strides_s>(),
        32usize,
        concat!("Size of: ", stringify!(ImageShape_image_strides_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ImageShape_image_strides_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ImageShape_image_strides_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_strides_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_strides_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_strides_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape_image_strides_s),
            "::",
            stringify!(planes)
        )
    );
}
#[test]
fn bindgen_test_layout_ImageShape() {
    const UNINIT: ::std::mem::MaybeUninit<ImageShape> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ImageShape>(),
        56usize,
        concat!("Size of: ", stringify!(ImageShape))
    );
    assert_eq!(
        ::std::mem::align_of::<ImageShape>(),
        8usize,
        concat!("Alignment of ", stringify!(ImageShape))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strides) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape),
            "::",
            stringify!(strides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageShape),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImageInfo {
    pub shape: ImageShape,
    pub hardware_timestamp: u64,
    pub hardware_frame_id: u64,
}
#[test]
fn bindgen_test_layout_ImageInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ImageInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ImageInfo>(),
        72usize,
        concat!("Size of: ", stringify!(ImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ImageInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageInfo),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardware_timestamp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageInfo),
            "::",
            stringify!(hardware_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardware_frame_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ImageInfo),
            "::",
            stringify!(hardware_frame_id)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct VideoFrame {
    #[doc = " The total number of bytes for this struct plus the\n size of the attached data buffer."]
    pub bytes_of_frame: usize,
    pub shape: ImageShape,
    pub frame_id: u64,
    pub hardware_frame_id: u64,
    pub timestamps: VideoFrame_video_frame_timestamps_s,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VideoFrame_video_frame_timestamps_s {
    pub hardware: u64,
    pub acq_thread: u64,
}
#[test]
fn bindgen_test_layout_VideoFrame_video_frame_timestamps_s() {
    const UNINIT: ::std::mem::MaybeUninit<VideoFrame_video_frame_timestamps_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VideoFrame_video_frame_timestamps_s>(),
        16usize,
        concat!("Size of: ", stringify!(VideoFrame_video_frame_timestamps_s))
    );
    assert_eq!(
        ::std::mem::align_of::<VideoFrame_video_frame_timestamps_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VideoFrame_video_frame_timestamps_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardware) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame_video_frame_timestamps_s),
            "::",
            stringify!(hardware)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acq_thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame_video_frame_timestamps_s),
            "::",
            stringify!(acq_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_VideoFrame() {
    const UNINIT: ::std::mem::MaybeUninit<VideoFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VideoFrame>(),
        96usize,
        concat!("Size of: ", stringify!(VideoFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<VideoFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(VideoFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_of_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(bytes_of_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(frame_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardware_frame_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(hardware_frame_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamps) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VideoFrame),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixelScale {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_PixelScale() {
    const UNINIT: ::std::mem::MaybeUninit<PixelScale> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PixelScale>(),
        16usize,
        concat!("Size of: ", stringify!(PixelScale))
    );
    assert_eq!(
        ::std::mem::align_of::<PixelScale>(),
        8usize,
        concat!("Alignment of ", stringify!(PixelScale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixelScale),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixelScale),
            "::",
            stringify!(y)
        )
    );
}
pub const PropertyType_PropertyType_FixedPrecision: PropertyType = 0;
pub const PropertyType_PropertyType_FloatingPrecision: PropertyType = 1;
pub const PropertyType_PropertyType_Enum: PropertyType = 2;
pub const PropertyType_PropertyType_String: PropertyType = 3;
pub type PropertyType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Property {
    pub writable: u8,
    pub low: f32,
    pub high: f32,
    pub type_: PropertyType,
}
#[test]
fn bindgen_test_layout_Property() {
    const UNINIT: ::std::mem::MaybeUninit<Property> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Property>(),
        16usize,
        concat!("Size of: ", stringify!(Property))
    );
    assert_eq!(
        ::std::mem::align_of::<Property>(),
        4usize,
        concat!("Alignment of ", stringify!(Property))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(writable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraProperties {
    pub exposure_time_us: f32,
    pub line_interval_us: f32,
    pub readout_direction: Direction,
    pub binning: u8,
    pub pixel_type: SampleType,
    pub offset: CameraProperties_camera_properties_offset_s,
    pub shape: CameraProperties_camera_properties_shape_s,
    pub input_triggers: CameraProperties_camera_properties_input_triggers_s,
    pub output_triggers: CameraProperties_camera_properties_output_triggers_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraProperties_camera_properties_offset_s {
    pub x: u32,
    pub y: u32,
}
#[test]
fn bindgen_test_layout_CameraProperties_camera_properties_offset_s() {
    const UNINIT: ::std::mem::MaybeUninit<CameraProperties_camera_properties_offset_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraProperties_camera_properties_offset_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CameraProperties_camera_properties_offset_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraProperties_camera_properties_offset_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraProperties_camera_properties_offset_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_offset_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_offset_s),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraProperties_camera_properties_shape_s {
    pub x: u32,
    pub y: u32,
}
#[test]
fn bindgen_test_layout_CameraProperties_camera_properties_shape_s() {
    const UNINIT: ::std::mem::MaybeUninit<CameraProperties_camera_properties_shape_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraProperties_camera_properties_shape_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CameraProperties_camera_properties_shape_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraProperties_camera_properties_shape_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraProperties_camera_properties_shape_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_shape_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_shape_s),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraProperties_camera_properties_input_triggers_s {
    pub acquisition_start: Trigger,
    pub frame_start: Trigger,
    pub exposure: Trigger,
}
#[test]
fn bindgen_test_layout_CameraProperties_camera_properties_input_triggers_s() {
    const UNINIT: ::std::mem::MaybeUninit<CameraProperties_camera_properties_input_triggers_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraProperties_camera_properties_input_triggers_s>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(CameraProperties_camera_properties_input_triggers_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraProperties_camera_properties_input_triggers_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraProperties_camera_properties_input_triggers_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquisition_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_input_triggers_s),
            "::",
            stringify!(acquisition_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_start) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_input_triggers_s),
            "::",
            stringify!(frame_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_input_triggers_s),
            "::",
            stringify!(exposure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraProperties_camera_properties_output_triggers_s {
    pub exposure: Trigger,
    pub frame_start: Trigger,
    pub trigger_wait: Trigger,
}
#[test]
fn bindgen_test_layout_CameraProperties_camera_properties_output_triggers_s() {
    const UNINIT: ::std::mem::MaybeUninit<CameraProperties_camera_properties_output_triggers_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraProperties_camera_properties_output_triggers_s>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(CameraProperties_camera_properties_output_triggers_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraProperties_camera_properties_output_triggers_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraProperties_camera_properties_output_triggers_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_output_triggers_s),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_start) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_output_triggers_s),
            "::",
            stringify!(frame_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger_wait) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties_camera_properties_output_triggers_s),
            "::",
            stringify!(trigger_wait)
        )
    );
}
#[test]
fn bindgen_test_layout_CameraProperties() {
    const UNINIT: ::std::mem::MaybeUninit<CameraProperties> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraProperties>(),
        108usize,
        concat!("Size of: ", stringify!(CameraProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<CameraProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(CameraProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure_time_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(exposure_time_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_interval_us) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(line_interval_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readout_direction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(readout_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binning) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(binning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(pixel_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_triggers) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(input_triggers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_triggers) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraProperties),
            "::",
            stringify!(output_triggers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata {
    pub exposure_time_us: Property,
    pub line_interval_us: Property,
    pub readout_direction: Property,
    pub binning: Property,
    pub offset: CameraPropertyMetadata_camera_properties_metadata_offset_s,
    pub shape: CameraPropertyMetadata_camera_properties_metadata_shape_s,
    #[doc = " bit field: bit i is 1 if SampleType(i) is supported, 0 otherwise"]
    pub supported_pixel_types: u64,
    pub digital_lines: CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata,
    pub triggers: CameraPropertyMetadata_CameraPropertiesTriggerMetadata,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata_camera_properties_metadata_offset_s {
    pub x: Property,
    pub y: Property,
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata_camera_properties_metadata_offset_s() {
    const UNINIT: ::std::mem::MaybeUninit<
        CameraPropertyMetadata_camera_properties_metadata_offset_s,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraPropertyMetadata_camera_properties_metadata_offset_s>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_offset_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraPropertyMetadata_camera_properties_metadata_offset_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_offset_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_offset_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_offset_s),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata_camera_properties_metadata_shape_s {
    pub x: Property,
    pub y: Property,
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata_camera_properties_metadata_shape_s() {
    const UNINIT: ::std::mem::MaybeUninit<
        CameraPropertyMetadata_camera_properties_metadata_shape_s,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraPropertyMetadata_camera_properties_metadata_shape_s>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_shape_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraPropertyMetadata_camera_properties_metadata_shape_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_shape_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_shape_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_camera_properties_metadata_shape_s),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata {
    #[doc = " The number of supported digital IO lines\n Must be less than 8."]
    pub line_count: u8,
    #[doc = " name[i] is a short, null terminated string naming line i.\n Support describing up to 8 names for use with triggering."]
    pub names: [[::std::os::raw::c_char; 64usize]; 8usize],
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<
        CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata>(),
        513usize,
        concat!(
            "Size of: ",
            stringify!(CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata),
            "::",
            stringify!(line_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_CameraPropertyMetadataDigitalLineMetadata),
            "::",
            stringify!(names)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata_CameraPropertiesTriggerMetadata { pub acquisition_start : CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s , pub exposure : CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s , pub frame_start : CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s , }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s
{
    #[doc = " Bit x is set if line x can be used as a trigger input."]
    pub input: u8,
    #[doc = " Bit x is set if line x can be used as a trigger output."]
    pub output: u8,
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s(
) {
    const UNINIT : :: std :: mem :: MaybeUninit < CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s > = :: std :: mem :: MaybeUninit :: uninit () ;
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s > () , 2usize , concat ! ("Size of: " , stringify ! (CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s)));
    assert_eq ! (:: std :: mem :: align_of :: < CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s > () , 1usize , concat ! ("Alignment of " , stringify ! (CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . input) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s) , "::" , stringify ! (input)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . output) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (CameraPropertyMetadata_CameraPropertiesTriggerMetadata_camera_properties_metadata_trigger_capabilities_s) , "::" , stringify ! (output)));
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata_CameraPropertiesTriggerMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<CameraPropertyMetadata_CameraPropertiesTriggerMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraPropertyMetadata_CameraPropertiesTriggerMetadata>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(CameraPropertyMetadata_CameraPropertiesTriggerMetadata)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CameraPropertyMetadata_CameraPropertiesTriggerMetadata>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CameraPropertyMetadata_CameraPropertiesTriggerMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquisition_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_CameraPropertiesTriggerMetadata),
            "::",
            stringify!(acquisition_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_CameraPropertiesTriggerMetadata),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_start) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata_CameraPropertiesTriggerMetadata),
            "::",
            stringify!(frame_start)
        )
    );
}
#[test]
fn bindgen_test_layout_CameraPropertyMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<CameraPropertyMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CameraPropertyMetadata>(),
        656usize,
        concat!("Size of: ", stringify!(CameraPropertyMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<CameraPropertyMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(CameraPropertyMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure_time_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(exposure_time_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_interval_us) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(line_interval_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readout_direction) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(readout_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binning) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(binning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_pixel_types) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(supported_pixel_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digital_lines) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(digital_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triggers) as usize - ptr as usize },
        649usize,
        concat!(
            "Offset of field: ",
            stringify!(CameraPropertyMetadata),
            "::",
            stringify!(triggers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Camera {
    pub device: Device,
    pub state: DeviceState,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Camera,
            settings: *mut CameraProperties,
        ) -> DeviceStatusCode,
    >,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const Camera,
            settings: *mut CameraProperties,
        ) -> DeviceStatusCode,
    >,
    pub get_meta: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const Camera,
            meta: *mut CameraPropertyMetadata,
        ) -> DeviceStatusCode,
    >,
    pub get_shape: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const Camera, shape: *mut ImageShape) -> DeviceStatusCode,
    >,
    pub start: ::std::option::Option<unsafe extern "C" fn(arg1: *mut Camera) -> DeviceStatusCode>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(arg1: *mut Camera) -> DeviceStatusCode>,
    pub execute_trigger:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut Camera) -> DeviceStatusCode>,
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Camera,
            im: *mut ::std::os::raw::c_void,
            nbytes: *mut usize,
            info: *mut ImageInfo,
        ) -> DeviceStatusCode,
    >,
}
#[test]
fn bindgen_test_layout_Camera() {
    const UNINIT: ::std::mem::MaybeUninit<Camera> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Camera>(),
        344usize,
        concat!("Size of: ", stringify!(Camera))
    );
    assert_eq!(
        ::std::mem::align_of::<Camera>(),
        8usize,
        concat!("Alignment of ", stringify!(Camera))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_meta) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(get_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_shape) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(get_shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).execute_trigger) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(execute_trigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera),
            "::",
            stringify!(get_frame)
        )
    );
}
